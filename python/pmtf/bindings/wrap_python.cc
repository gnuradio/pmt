/*
 * Copyright 2020 Free Software Foundation, Inc.
 *
 * This file is part of GNU Radio
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/* This file is automatically generated using bindtool */

#include <pybind11/complex.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace py = pybind11;

#include <pmtf/scalar.hpp>
#include <pmtf/string.hpp>
#include <pmtf/vector.hpp>
#include <pmtf/wrap.hpp>
// pydoc.h is automatically generated in the build directory
// #include <pmt_pydoc.h>

void bind_wrap(py::module &m) {
  using wrap = pmtf::wrap;

  py::class_<wrap, std::shared_ptr<wrap>>(m, "wrap")

      // String Wrapper
      .def(py::init([](const std::string &str) { return pmtf::wrap(str); }))

      // Scalar Wrappers
      .def(py::init([](const bool &val) { return pmtf::wrap(val); }))
      .def(py::init([](const int8_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const uint8_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const int16_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const uint16_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const int32_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const uint32_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const int64_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const uint64_t &val) { return pmtf::wrap(val); }))
      .def(py::init([](const float &val) { return pmtf::wrap(val); }))
      .def(py::init([](const double &val) { return pmtf::wrap(val); }))
      .def(py::init([](const std::vector<std::complex<float>> &val) {
        return pmtf::wrap(val);
      }))
      //   .def(py::init([](const std::vector<std::complex<double>> &val) {
      //     return pmtf::wrap(val);
      //   }))
      // Vector Wrappers
      //   .def(py::init(
      //       [](const std::vector<bool> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<int8_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<uint8_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<int16_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<uint16_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<int32_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<uint32_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<int64_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<uint64_t> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<float> &vec) { return pmtf::wrap(vec); }))
      .def(py::init(
          [](const std::vector<double> &vec) { return pmtf::wrap(vec); }))
      .def(py::init([](const std::vector<std::complex<float>> &vec) {
        return pmtf::wrap(vec);
      }))
      //   .def(py::init([](const std::vector<std::complex<double>> &vec) {
      //     return pmtf::wrap(vec);
      //   }))

      .def("__call__", [](pmtf::wrap obj) {
        pmtf::wrap_variant_t ret;

        switch (obj.ptr()->data_type()) {
        case pmtf::Data::PmtString:
          ret = pmtf::get_string(obj).value();
          break;
          //   case pmtf::Data::VectorBool:
          //     ret = pmtf::get_vector<bool>(obj).value();
          //     break;
        case pmtf::Data::VectorFloat32:
          ret = pmtf::get_vector<float>(obj).value();
          break;
        case pmtf::Data::VectorFloat64:
          ret = pmtf::get_vector<double>(obj).value();
          break;
        case pmtf::Data::VectorComplex64:
          ret = pmtf::get_vector<std::complex<float>>(obj).value();
          break;
          //   case pmtf::Data::VectorComplex128:
          //     ret = pmtf::get_vector<std::complex<double>>(obj).value();
          //     break;
        case pmtf::Data::VectorInt8:
          ret = pmtf::get_vector<int8_t>(obj).value();
          break;
        case pmtf::Data::VectorInt16:
          ret = pmtf::get_vector<int16_t>(obj).value();
          break;
        case pmtf::Data::VectorInt32:
          ret = pmtf::get_vector<int32_t>(obj).value();
          break;
        case pmtf::Data::VectorInt64:
          ret = pmtf::get_vector<int64_t>(obj).value();
          break;
        case pmtf::Data::VectorUInt8:
          ret = pmtf::get_vector<uint8_t>(obj).value();
          break;
        case pmtf::Data::VectorUInt16:
          ret = pmtf::get_vector<uint16_t>(obj).value();
          break;
        case pmtf::Data::VectorUInt32:
          ret = pmtf::get_vector<uint32_t>(obj).value();
          break;
        case pmtf::Data::VectorUInt64:
          ret = pmtf::get_vector<uint64_t>(obj).value();
          break;
          //   case pmtf::Data::ScalarBool:
          //     ret = pmtf::get_scalar<bool>(obj).value();
          //     break;
        case pmtf::Data::ScalarFloat32:
          ret = pmtf::get_scalar<float>(obj).value();
          break;
        case pmtf::Data::ScalarFloat64:
          ret = pmtf::get_scalar<double>(obj).value();
          break;
        case pmtf::Data::ScalarComplex64:
          ret = pmtf::get_scalar<std::complex<float>>(obj).value();
          break;
          //   case pmtf::Data::ScalarComplex128:
          //     ret = pmtf::get_scalar<std::complex<double>>(obj).value();
          //     break;
        case pmtf::Data::ScalarInt8:
          ret = pmtf::get_scalar<int8_t>(obj).value();
          break;
        case pmtf::Data::ScalarInt16:
          ret = pmtf::get_scalar<int16_t>(obj).value();
          break;
        case pmtf::Data::ScalarInt32:
          ret = pmtf::get_scalar<int32_t>(obj).value();
          break;
        case pmtf::Data::ScalarInt64:
          ret = pmtf::get_scalar<int64_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt8:
          ret = pmtf::get_scalar<uint8_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt16:
          ret = pmtf::get_scalar<uint16_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt32:
          ret = pmtf::get_scalar<uint32_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt64:
          ret = pmtf::get_scalar<uint64_t>(obj).value();
          break;
        default:
          throw std::runtime_error("Invalid Scalar PMT type!");
        }

        return ret;
      });
}
