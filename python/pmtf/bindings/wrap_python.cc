/*
 * Copyright 2020 Free Software Foundation, Inc.
 *
 * This file is part of GNU Radio
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/* This file is automatically generated using bindtool */

#include <pybind11/complex.h>
#include <pybind11/numpy.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace py = pybind11;

#include <pmtf/scalar.hpp>
#include <pmtf/string.hpp>
#include <pmtf/vector.hpp>
#include <pmtf/wrap.hpp>
// pydoc.h is automatically generated in the build directory
// #include <pmt_pydoc.h>
#include <pybind11/stl_bind.h>

// PYBIND11_MAKE_OPAQUE(std::map<std::string, pmtf::pmt>)

namespace pmtf {
using pmt_variant_t = std::variant<std::nullptr_t,
                                   std::string,
                                   bool,
                                   int8_t,
                                   uint8_t,
                                   int16_t,
                                   uint16_t,
                                   int32_t,
                                   uint32_t,
                                   int64_t,
                                   uint64_t,
                                   float,
                                   double,
                                   std::complex<float>,
                                   std::complex<double>,
                                   std::vector<bool>,
                                   std::vector<int8_t>,
                                   std::vector<uint8_t>,
                                   std::vector<int16_t>,
                                   std::vector<uint16_t>,
                                   std::vector<int32_t>,
                                   std::vector<uint32_t>,
                                   std::vector<int64_t>,
                                   std::vector<uint64_t>,
                                   std::vector<float>,
                                   std::vector<double>,
                                   std::vector<std::complex<float>>,
                                   std::vector<std::complex<double>>,
                                   std::map<std::string, pmtf::pmt>,
                                   py::array_t<bool>,
                                   py::array_t<int8_t>,
                                   py::array_t<uint8_t>,
                                   py::array_t<int16_t>,
                                   py::array_t<uint16_t>,
                                   py::array_t<int32_t>,
                                   py::array_t<uint32_t>,
                                   py::array_t<int64_t>,
                                   py::array_t<uint64_t>,
                                   py::array_t<float>,
                                   py::array_t<double>,
                                   py::array_t<std::complex<float>>,
                                   py::array_t<std::complex<double>>>;
}

template <typename T>
static pmtf::pmt _np_to_pmt(py::array_t<T> np_vec)
{
    return pmtf::pmt(
        std::vector<T>(static_cast<const T*>(np_vec.data()),
                       static_cast<const T*>(np_vec.data()) + np_vec.size()));
}

template <typename T>
static py::array_t<T> _pmt_to_np(pmtf::pmt p)
{
    auto vec = pmtf::vector<T>(p);
    return py::array_t<T>(vec.size(), vec.data());
}

void bind_pmt(py::module& m)
{
    using pmt = pmtf::pmt;

    // py::bind_map<std::map<std::string, pmtf::pmt>>(m, "PmtMap");

    py::class_<pmt, std::shared_ptr<pmt>>(m, "pmt")

        // Null Wrapper
        .def(py::init([]() { return pmtf::pmt(); }))

        // Map Wrapper
        .def(py::init([](const std::map<std::string, pmtf::pmt>& themap) {
            return pmtf::pmt(themap);
        }))

        // String Wrapper
        .def(py::init([](const std::string& str) { return pmtf::pmt(str); }))

        // Scalar Wrappers
        .def(py::init([](const bool& val) { return pmtf::pmt(val); }))
        .def(py::init([](const int8_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const uint8_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const int16_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const uint16_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const int32_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const uint32_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const int64_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const uint64_t& val) { return pmtf::pmt(val); }))
        .def(py::init([](const float& val) { return pmtf::pmt(val); }))
        .def(py::init([](const double& val) { return pmtf::pmt(val); }))
        .def(py::init([](const std::complex<float>& val) { return pmtf::pmt(val); }))
        .def(py::init([](const std::complex<double>& val) { return pmtf::pmt(val); }))

        // Vector Wrappers
        // .def(py::init([](const std::vector<bool>& vec) { return pmtf::pmt(vec); }))
        .def(py::init([](const py::array_t<int8_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<int16_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<int32_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<int64_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<uint8_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<uint16_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<uint32_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<uint64_t>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<float>& vec) { return _np_to_pmt(vec); }))
        .def(py::init([](const py::array_t<double>& vec) { return _np_to_pmt(vec); }))
        .def(py::init(
            [](const py::array_t<std::complex<float>>& vec) { return _np_to_pmt(vec); }))
        .def(py::init(
            [](const py::array_t<std::complex<double>>& vec) { return _np_to_pmt(vec); }))

        .def("__call__",
             [](pmtf::pmt obj) {
                 pmtf::pmt_variant_t ret;

                 switch (obj.data_type()) {
                 case pmtf::Data::PmtString: {
                     auto str = pmtf::string(obj).value();
                     ret = std::string(str.begin(), str.end());
                     break;
                 }
                     //   case pmtf::Data::VectorBool:
                     //     ret = pmtf::vector<bool>(obj).value();
                     //     break;
                 case pmtf::Data::VectorFloat32:
                     ret = _pmt_to_np<float>(obj);
                     break;
                 case pmtf::Data::VectorFloat64:
                     ret = _pmt_to_np<double>(obj);
                     break;
                 case pmtf::Data::VectorComplex64:
                     ret = _pmt_to_np<std::complex<float>>(obj);
                     break;
                 case pmtf::Data::VectorComplex128:
                     ret = _pmt_to_np<std::complex<double>>(obj);
                     break;
                 case pmtf::Data::VectorInt8:
                     ret = _pmt_to_np<int8_t>(obj);
                     break;
                 case pmtf::Data::VectorInt16:
                     ret = _pmt_to_np<int16_t>(obj);
                     break;
                 case pmtf::Data::VectorInt32:
                     ret = _pmt_to_np<int32_t>(obj);
                     break;
                 case pmtf::Data::VectorInt64:
                     ret = _pmt_to_np<int64_t>(obj);
                     break;
                 case pmtf::Data::VectorUInt8:
                     ret = _pmt_to_np<uint8_t>(obj);
                     break;
                 case pmtf::Data::VectorUInt16:
                     ret = _pmt_to_np<uint16_t>(obj);
                     break;
                 case pmtf::Data::VectorUInt32:
                     ret = _pmt_to_np<uint32_t>(obj);
                     break;
                 case pmtf::Data::VectorUInt64:
                     ret = _pmt_to_np<uint64_t>(obj);
                     break;
                     //   case pmtf::Data::ScalarBool:
                     //     ret = pmtf::scalar<bool>(obj).value();
                     //     break;
                 case pmtf::Data::ScalarFloat32:
                     ret = pmtf::scalar<float>(obj).value();
                     break;
                 case pmtf::Data::ScalarFloat64:
                     ret = pmtf::scalar<double>(obj).value();
                     break;
                 case pmtf::Data::ScalarComplex64:
                     ret = pmtf::scalar<std::complex<float>>(obj).value();
                     break;
                     //   case pmtf::Data::ScalarComplex128:
                     //     ret = pmtf::scalar<std::complex<double>>(obj).value();
                     //     break;
                 case pmtf::Data::ScalarInt8:
                     ret = pmtf::scalar<int8_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarInt16:
                     ret = pmtf::scalar<int16_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarInt32:
                     ret = pmtf::scalar<int32_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarInt64:
                     ret = pmtf::scalar<int64_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarUInt8:
                     ret = pmtf::scalar<uint8_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarUInt16:
                     ret = pmtf::scalar<uint16_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarUInt32:
                     ret = pmtf::scalar<uint32_t>(obj).value();
                     break;
                 case pmtf::Data::ScalarUInt64:
                     ret = pmtf::scalar<uint64_t>(obj).value();
                     break;
                 default:
                     throw std::runtime_error("Invalid Scalar PMT type!");
                 }

                 return ret;
             })
        .def("serialize",
             [](pmtf::pmt obj) {
                 std::stringbuf sb; // fake channel
                 auto nbytes = obj.serialize(sb);
                 std::vector<uint8_t> pre_encoded_str(nbytes, 0);
                 sb.sgetn((char*)pre_encoded_str.data(), nbytes);
                 return pre_encoded_str;
             })
        .def("to_base64", &pmtf::pmt::to_base64)
        .def_static("from_base64", &pmtf::pmt::from_base64);

    // py::bind_map<std::map<std::string, pmtf::pmt>>(m, "PmtMap");
}
