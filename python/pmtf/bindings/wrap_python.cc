/*
 * Copyright 2020 Free Software Foundation, Inc.
 *
 * This file is part of GNU Radio
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/* This file is automatically generated using bindtool */

#include <pybind11/complex.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace py = pybind11;

#include <pmtf/scalar.hpp>
#include <pmtf/string.hpp>
#include <pmtf/vector.hpp>
#include <pmtf/wrap.hpp>
// pydoc.h is automatically generated in the build directory
// #include <pmt_pydoc.h>

void bind_pmt(py::module &m) {
  using pmt = pmtf::pmt;

  py::class_<pmt, std::shared_ptr<pmt>>(m, "pmt")

      // String Wrapper
      .def(py::init([](const std::string &str) { return pmtf::pmt(str); }))

      // Scalar Wrappers
      .def(py::init([](const bool &val) { return pmtf::pmt(val); }))
      .def(py::init([](const int8_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const uint8_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const int16_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const uint16_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const int32_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const uint32_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const int64_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const uint64_t &val) { return pmtf::pmt(val); }))
      .def(py::init([](const float &val) { return pmtf::pmt(val); }))
      .def(py::init([](const double &val) { return pmtf::pmt(val); }))
      .def(py::init([](const std::vector<std::complex<float>> &val) {
        return pmtf::pmt(val);
      }))
      //   .def(py::init([](const std::vector<std::complex<double>> &val) {
      //     return pmtf::pmt(val);
      //   }))
      // Vector Wrappers
      //   .def(py::init(
      //       [](const std::vector<bool> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<int8_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<uint8_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<int16_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<uint16_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<int32_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<uint32_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<int64_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<uint64_t> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<float> &vec) { return pmtf::pmt(vec); }))
      .def(py::init(
          [](const std::vector<double> &vec) { return pmtf::pmt(vec); }))
      .def(py::init([](const std::vector<std::complex<float>> &vec) {
        return pmtf::pmt(vec);
      }))
      //   .def(py::init([](const std::vector<std::complex<double>> &vec) {
      //     return pmtf::pmt(vec);
      //   }))

      .def("__call__", [](pmtf::pmt obj) {
        pmtf::pmt_variant_t ret;

        switch (obj.data_type()) {
        case pmtf::Data::PmtString:
        {
          auto str = pmtf::get_string(obj).value();
          ret = std::string(str.begin(), str.end());
          break;
        }
          //   case pmtf::Data::VectorBool:
          //     ret = pmtf::get_vector<bool>(obj).value();
          //     break;
        case pmtf::Data::VectorFloat32:
          ret = pmtf::get_std_vector<float>(obj);
          break;
        case pmtf::Data::VectorFloat64:
          ret = pmtf::get_std_vector<double>(obj);
          break;
        case pmtf::Data::VectorComplex64:
          ret = pmtf::get_std_vector<std::complex<float>>(obj);
          break;
          //   case pmtf::Data::VectorComplex128:
          //     ret = pmtf::get_vector<std::complex<double>>(obj).value();
          //     break;
        case pmtf::Data::VectorInt8:
          ret = pmtf::get_std_vector<int8_t>(obj);
          break;
        case pmtf::Data::VectorInt16:
          ret = pmtf::get_std_vector<int16_t>(obj);
          break;
        case pmtf::Data::VectorInt32:
          ret = pmtf::get_std_vector<int32_t>(obj);
          break;
        case pmtf::Data::VectorInt64:
          ret = pmtf::get_std_vector<int64_t>(obj);
          break;
        case pmtf::Data::VectorUInt8:
          ret = pmtf::get_std_vector<uint8_t>(obj);
          break;
        case pmtf::Data::VectorUInt16:
          ret = pmtf::get_std_vector<uint16_t>(obj);
          break;
        case pmtf::Data::VectorUInt32:
          ret = pmtf::get_std_vector<uint32_t>(obj);
          break;
        case pmtf::Data::VectorUInt64:
          ret = pmtf::get_std_vector<uint64_t>(obj);
          break;
          //   case pmtf::Data::ScalarBool:
          //     ret = pmtf::get_scalar<bool>(obj).value();
          //     break;
        case pmtf::Data::ScalarFloat32:
          ret = pmtf::get_scalar<float>(obj).value();
          break;
        case pmtf::Data::ScalarFloat64:
          ret = pmtf::get_scalar<double>(obj).value();
          break;
        case pmtf::Data::ScalarComplex64:
          ret = pmtf::get_scalar<std::complex<float>>(obj).value();
          break;
          //   case pmtf::Data::ScalarComplex128:
          //     ret = pmtf::get_scalar<std::complex<double>>(obj).value();
          //     break;
        case pmtf::Data::ScalarInt8:
          ret = pmtf::get_scalar<int8_t>(obj).value();
          break;
        case pmtf::Data::ScalarInt16:
          ret = pmtf::get_scalar<int16_t>(obj).value();
          break;
        case pmtf::Data::ScalarInt32:
          ret = pmtf::get_scalar<int32_t>(obj).value();
          break;
        case pmtf::Data::ScalarInt64:
          ret = pmtf::get_scalar<int64_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt8:
          ret = pmtf::get_scalar<uint8_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt16:
          ret = pmtf::get_scalar<uint16_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt32:
          ret = pmtf::get_scalar<uint32_t>(obj).value();
          break;
        case pmtf::Data::ScalarUInt64:
          ret = pmtf::get_scalar<uint64_t>(obj).value();
          break;
        default:
          throw std::runtime_error("Invalid Scalar PMT type!");
        }

        return ret;
      })
      .def("serialize",  [](pmtf::pmt obj) { 
        std::stringbuf sb; // fake channel
        auto nbytes = obj.serialize(sb);
        std::vector<uint8_t> pre_encoded_str(nbytes, 0);
        sb.sgetn((char *)pre_encoded_str.data(), nbytes);
        return pre_encoded_str;
      })
      ;
}
